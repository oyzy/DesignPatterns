结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

适配器模式（Adapter）
    适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配
    器模式、对象的适配器模式、接口的适配器模式。

    三种适配器模式的应用场景：
        类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口
        即可。

        对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的
        方法中，调用实例的方法就行。

        接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象
        类即可。


装饰模式（Decorator）
    装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例

    装饰器模式的应用场景：
        1、需要扩展一个类的功能。
        2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
        缺点：产生过多相似的对象，不易排错！


代理模式（Proxy）
    代理模式就是多一个代理类出来，替原对象进行一些操作。

    代理模式的应用场景：
        如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
            1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
            2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
        使用代理模式，可以将功能划分的更加清晰，有助于后期维护！


外观模式（Facade）
    外观模式是为了解决类与类之间的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一
    个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。


桥接模式（Bridge）
    桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常
    用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因
    就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了


组合模式（Composite）
    组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便。
    使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中。


享元模式（Flyweight）
    享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

    FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存
    在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，
    我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password
    及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外
    部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。

    通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！
